node('Kas') {
  try {
    notifyBuild('STARTED')

    checkout scm

    sh 'docker-compose pull'

    appName       = sh(returnStdout: true, script: 'docker-compose run --rm printenv APP_NAME').trim()
    gitCommit     = sh(returnStdout: true, script: 'git rev-parse --short --verify HEAD').trim()
    containerName = "metova/${appName}"
    railsEnv      = sh(returnStdout: true, script: 'docker-compose run --rm printenv RAILS_ENV').trim()

    if (!appName?.trim()) {
      error('You must set APP_NAME in the env file!')
    }

    stage('Setup') {
      sh 'docker volume create --name gems'
      sh "docker-compose build"
    }

    stage('Bundle') {
      sh 'docker-compose run --rm bundle'
    }

    if (railsEnv == 'staging') {
      stage('Test') {
        sh 'docker-compose run --rm cleanup'
        sh 'docker-compose run --rm test'
        step([$class: 'JUnitResultArchiver', testResults: '**/reports/junit.xml'])
        publishHTML([reportDir: 'coverage', reportFiles: 'index.html', reportName: 'Ruby Coverage'])
      }
    }

    stage('Containerize') {
      sh "docker-compose pull acr-login acr-get-url"

      // Login to Azure
      sh "docker-compose run --rm azure-cli az login --service-principal --username $AZ_USERNAME --password $AZ_PASSWORD --tenant $AZ_TENANT"

      // Login to Azure Container Registry
      cmd = sh returnStdout: true, script: "docker-compose run --rm acr-login"
      sh "${cmd}"

      // Store the URL to the ACS repository
      acrUrl = sh returnStdout: true, script: "docker-compose run --rm acr-get-url"

      // Build the container according to the config/deploy Dockerfile
      sh """
      docker build --pull \
      --build-arg RAILS_MASTER_KEY=\$RAILS_MASTER_KEY \
      --build-arg RAILS_ENV=\$RAILS_ENV \
      --build-arg GIT_COMMIT=${gitCommit} \
      -f config/deploy/Dockerfile -t ${containerName} .
      """

      // Tag and push the container to the ECS repository
      finalImageName = "${acrUrl}/${containerName}:${gitCommit}-${currentBuild.number}".replaceAll("\n", "")
      sh "docker tag ${containerName}:latest ${finalImageName}"
      echo "Pushing ${finalImageName}"
      sh "docker push ${finalImageName}"
    }

    stage('Deploy') {
      manifest = sh returnStdout: true, script: "IMAGE=${finalImageName} docker-compose run --rm generate-kube-manifest"
      sh "echo '${manifest}' | docker-compose run --rm azure-cli /app/bin/deploy_${railsEnv}"
    }
  } catch (e) {
    // If there was an exception thrown, the build failed
    currentBuild.result = "FAILED"
    throw e
  } finally {
    // Success or failure, always send notifications
    notifyBuild(currentBuild.result)
  }
}

def notifyBuild(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
  def summary = "${subject} (${env.BUILD_URL})"
  def details = """<p>STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':</p>
    <p>Check console output at "<a href="${env.BUILD_URL}">${env.JOB_NAME} [${env.BUILD_NUMBER}]</a>"</p>"""

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'YELLOW'
    colorCode = '#FFFF00'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#00FF00'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
  }

  // Send notification
  hipchatSend (color: color, notify: true, message: summary, room: 'BridgeMart')
}
